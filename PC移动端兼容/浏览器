一。内存：
V8 把堆内存分成了两部分进行处理——新生代内存和老生代内存。
新生代就是临时分配的内存，存活时间短。
老生代是常驻内存，存活的时间长。

二。V8引擎内存回收：
新生代内存：
新生代内存被一分为二，当进行垃圾回收时，V8 将From部分的对象检查一遍，如果是存活对象那么复制到To内存中(在To内存中按照顺序从头放置的)，如果是非存活对象直接回收。
当所有的From中的存活对象按照顺序进入到To内存之后，From 和 To 两者的角色对调，From现在被闲置，To为正在使用，如此循环。
新生代垃圾回收算法也叫Scavenge算法。
老生代内存：
新生代中的变量经过回收后依然存在，会被放入到老生代内存中，这种现象就叫晋升。
第一步，进行标记-清除。遍历堆中的所有对象，做上标记，对于代码环境中使用的变量以及被强引用的变量取消标记，删除剩余标记变量。
第二步，整理内存碎片。清除阶段结束后，把存活的对象全部往一端靠拢（移动对象，耗时）。
增量标记（标记优化）
由于JS的单线程机制，V8 在进行垃圾回收的时候，不可避免地会阻塞业务逻辑的执行，倘若老生代的垃圾回收任务很重，那么耗时会非常可怕，严重影响应用的性能。那这个时候为了避免这样问题，V8 采取了增量标记的方案，即将一口气完成的标记任务分为很多小的部分完成，每做完一个小的部分就"歇"一下，就js应用逻辑执行一会儿，然后再执行下面的部分，如果循环，直到标记阶段完成才进入内存碎片的整理上面来

V8执行js代码：
js代码 => 字节码 => 机器码
1.首先通过词法分析和语法分析生成 AST
2.将 AST 转换为字节码
3.由解释器逐行执行字节码，遇到热点代码启动编译器进行编译，生成对应的机器码, 以优化执行效率

三。EventLoop——宏任务和微任务
宏任务：任务队列+延迟队列
1.渲染事件
2.用户交互事件
3.js脚本执行
4.网络请求、文件读写完成事件等等。
5.setTimeout/setInterval定时器任务
微任务：MutationObserver、Promise.then(或.reject) 以及以 Promise 为基础开发的其他技术(比如fetch API), 还包括 V8 的垃圾回收过程


四。浏览器缓存
1.强缓存：
服务端返回的响应头部：
Expires：设置过期时间（http1.0支持）  隐患：服务器的时间和浏览器的时间可能并不一致  
Cache-Control：设置过期时长来控制缓存（http1.1支持）例子：max-age=3600

资源缓存时间超时，强缓存失效，开始协商缓存。
2.协商缓存：
强缓存失效之后，浏览器在请求头中携带相应的缓存tag（Last-Modified 和 ETag）来向服务器发请求，由服务器根据这个tag，来决定是否使用缓存，这就是协商缓存。
Last-Modified：即最后修改时间。第一次请求时，服务端会加上此字段。客户端再次请求时（If-Modified-Since），比对时间和最新修改资源时间是否一致。一致返回304，不一致返回最新资源。
ETag：服务器根据当前文件的内容，给文件生成的唯一标识，只要内容有改动，这个值就会变。客户端发送字段（If-None-Match）

比较：在精准度上，ETag优于Last-Modified。在性能上，Last-Modified优于ETag

缓存位置
浏览器中的缓存位置一共有四种，优先级从高到低排列分别是：
Service Worker （离线缓存）
Memory Cache（内存缓存）
Disk Cache（磁盘缓存）
Push Cache （推送缓存 ）HTTP/2.0产物

Memory Cache和Disk Cache使用策略：
比较大的JS、CSS文件会直接被丢进磁盘，反之丢进内存
内存使用率比较高的时候，文件优先进入磁盘

浏览器的本地存储
cookie：弥补HTTP在状态管理上的不足，Cookie 本质上就是浏览器里面存储的一个很小的文本文件，键值对格式，向同一个域名下发送请求，带上cookie信息，以便服务端拿到客户端状态。
缺点：
1.容量缺陷。Cookie 的体积上限只有4KB，只能存储少量的信息。
2.性能缺陷。Cookie 紧跟域名，不管域名下面的某一个地址需不需要这个 Cookie ，请求都会携带上完整的 Cookie，这样随着请求数的增多，其实会造成巨大的性能浪费的。
3.安全缺陷。由于 Cookie 以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截获，进行一系列的篡改，在 Cookie 的有效期内重新发送给服务器，这是相当危险的。另外，在HttpOnly为 false 的情况下，Cookie 信息能直接通过 JS 脚本来读取。

webstorage：sessionStorage和localStorage
同：
1.容量上限也为 5M；
2.只存在客户端，不参与与服务端的通信；
3.存储获取操作接口一致；
异：
sessionStorage是会话级别存储，localStorage是持久性存储

webstorage和cookie的区别
同：存储数据和绑定域名紧密关联
异：
1.cookie 4kb空间，webstorage 5M空间 
2.webstorage不参与服务端通信，避免了cookie性能问题

IndexedDB：运行在浏览器上的非关系型数据库，为大型数据的存储提供了接口，容量是没有上限。

五。输入网址浏览器做了什么：
网络篇：

解析构建篇：

渲染过程篇：

六。重绘和回流（重排）
回流：当我们对 DOM 结构的修改引发 DOM 几何尺寸变化的时候，会发生回流
触发场景：
1.一个 DOM 元素的几何属性变化，常见的几何属性有width、height、padding、margin、left、top、border 等等, 这个很好理解。
2.使 DOM 节点发生增减或者移动。
3.读写 offset族、scroll族和client族属性的时候，浏览器为了获取这些值，需要进行回流操作。
4.调用 window.getComputedStyle 方法。

如果 DOM 结构发生改变，则重新渲染 DOM 树，然后将后面的流程(包括主线程之外的任务)全部走一遍。开销大。

重绘：DOM 的修改导致样式的变化，并且没有影响几何属性的时候，会导致重绘(repaint)。

指导意义：
1.避免频繁使用 style，而是采用修改class的方式。
2.使用createDocumentFragment进行批量的 DOM 操作。
3. 对于 resize、scroll 等进行防抖/节流处理。
4.添加 will-change: tranform ，让渲染引擎为其单独实现一个图层，当这些变换发生时，仅仅只是利用合成线程去处理这些变换，而不牵扯到主线程，大大提高渲染效率。当然这个变化不限于tranform, 任何可以实现合成效果的 CSS 属性都能用will-change来声明。

